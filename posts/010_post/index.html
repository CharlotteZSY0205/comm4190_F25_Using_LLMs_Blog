<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shiyang Zhang">
<meta name="dcterms.date" content="2025-10-23">
<meta name="description" content="I tested ChatGPT’s new Study Mode to see if it could resist the “write my essay” temptation—and actually guide students to learn, not just generate text.">

<title>ChatGPT Study Mode: Testing Its Pedagogical Promise – Shiyang’s Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1db3f541d99483cdc7a0d9cf38862b2c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Shiyang’s Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">ChatGPT Study Mode: Testing Its Pedagogical Promise</h1>
                  <div>
        <div class="description">
          I tested ChatGPT’s new Study Mode to see if it could resist the “write my essay” temptation—and actually guide students to learn, not just generate text.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">ChatGPT</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shiyang Zhang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 23, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Here’s your text formatted cleanly in <strong>Markdown (MD)</strong> for direct use in a blog or repository:</p>
<hr>
<section id="testing-chatgpt-study-mode-can-it-resist-the-write-my-essay-temptation" class="level1">
<h1>Testing ChatGPT Study Mode: Can It Resist the “Write My Essay” Temptation?</h1>
<p>Many studies have found that college students often turn to ChatGPT to write their essays. So when ChatGPT launched its new <strong>Study Mode</strong>, I couldn’t help but wonder: can it really resist the temptation of a “Write my essay” prompt—and actually teach students how to write better?</p>
<hr>
<section id="chatgpt-study-mode" class="level2">
<h2 class="anchored" data-anchor-id="chatgpt-study-mode">ChatGPT Study Mode</h2>
<blockquote class="blockquote">
<p>“When students engage with study mode, they’re met with guiding questions that calibrate responses to their objective and skill level to help them build deeper understanding. Study mode is designed to be engaging and interactive, and to help students learn something—not just finish something.” — <a href="https://openai.com/index/chatgpt-study-mode/">OpenAI, <em>ChatGPT Study Mode</em></a></p>
</blockquote>
<hr>
</section>
<section id="research-background" class="level2">
<h2 class="anchored" data-anchor-id="research-background">Research Background</h2>
<p>This experiment grew out of one of my research projects on how students use ChatGPT in writing. For the study, I selected <strong>21 prompts</strong> from the <strong>RECIPE4U</strong> dataset — a publicly available collection of interaction histories between <strong>212 college students</strong> and ChatGPT in an English writing course (Sawalha et al., 2024a).</p>
<p>In that course, students used ChatGPT to help revise their essays, and the dataset records their entire conversations, including the <strong>original prompts</strong>, <strong>dialogue exchanges</strong>, <strong>annotated writing intentions</strong>, and <strong>final revised essays</strong>. Using a subset of these authentic prompts, I tested ChatGPT’s <strong>Study Mode</strong> to see how well it supports learning-oriented writing guidance compared with ordinary prompts.</p>
<hr>
</section>
<section id="experiment-setup" class="level2">
<h2 class="anchored" data-anchor-id="experiment-setup">Experiment Setup</h2>
<p>The 21 prompts we selected were all labeled <strong>“Content Generation.”</strong> Based on both my classroom observations and prior research, many college students tend to use ChatGPT primarily to generate essays directly rather than to learn or revise through it.</p>
<p>I wanted to test whether ChatGPT’s Study Mode could truly support <strong>learning and knowledge transformation</strong>—as it claims to—rather than simply producing finished text. To do this, I took those prompts that originally requested direct generation and ran them in ChatGPT’s Study Mode.</p>
<hr>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>However, to my disappointment, <strong>14 out of 21 responses</strong> directly produced <strong>ready-made text</strong>, just as the users originally requested. Here are some examples.</p>
<hr>
<section id="example-1" class="level3">
<h3 class="anchored" data-anchor-id="example-1">Example 1</h3>
<p><strong>Prompt from the dataset:</strong></p>
<blockquote class="blockquote">
<p>Can you rewrite the body paragraph by breaking up the body paragraphs into subheadings. {the student’s essay}.</p>
</blockquote>
<p><strong>ChatGPT said:</strong></p>
<blockquote class="blockquote">
<p>Good — before I rewrite anything, let’s make sure you understand <em>why</em> and <em>how</em> subheadings help.</p>
<p>Subheadings give readers “signposts” so they can easily follow the structure of your essay. Each main idea (like <strong>Convenience</strong>, <strong>Affordability</strong>, <strong>Health Problems</strong>, etc.) becomes its own section.</p>
<p>Let’s try this step-by-step. Your essay’s body paragraphs seem to focus on three big ideas:</p>
<ol type="1">
<li><strong>Convenience of Fast Food</strong></li>
<li><strong>Affordability and Accessibility</strong></li>
<li><strong>Negative Health and Social Effects</strong></li>
</ol>
</blockquote>
<p>Here’s a sample outline of how those subheadings could look — not rewritten yet, just organized:</p>
<hr>
</section>
<section id="convenience-of-fast-food" class="level3">
<h3 class="anchored" data-anchor-id="convenience-of-fast-food"><strong>1. Convenience of Fast Food</strong></h3>
<p>Explain how location, opening hours, and speed make fast food easy to access.</p>
</section>
<section id="affordability-and-accessibility" class="level3">
<h3 class="anchored" data-anchor-id="affordability-and-accessibility"><strong>2. Affordability and Accessibility</strong></h3>
<p>Describe why fast food is cheap — simple menus, pre-packaged ingredients, low overhead — and how it helps people on tight budgets.</p>
</section>
<section id="health-and-social-consequences" class="level3">
<h3 class="anchored" data-anchor-id="health-and-social-consequences"><strong>3. Health and Social Consequences</strong></h3>
<p>Discuss obesity, diabetes, heart disease, and mental health issues, then mention environmental and economic impacts.</p>
<hr>
<p>Now, here’s your task: Can you tell me which tone you’d like for the rewritten version — a) <strong>academic essay style</strong> (formal, polished, transitions like <em>furthermore</em>, <em>moreover</em>) or b) <strong>clear student essay style</strong> (simple and natural, easy to read)?</p>
<p><strong>I said:</strong></p>
<blockquote class="blockquote">
<p>academic essay style</p>
</blockquote>
<p><strong>ChatGPT said:</strong></p>
<blockquote class="blockquote">
<p>Got it — here’s a <strong>clear student essay style</strong> version of the paragraph:</p>
<p><em>Causal inference methods are used in deep learning to help models make fairer and more accurate predictions. These methods teach models to find real cause-and-effect relationships instead of just copying patterns from the data…</em></p>
</blockquote>
<p>Would you like me to show how this could fit smoothly into a longer essay section (for example, adding a short introduction or transition before it)?</p>
<hr>
</section>
<section id="example-2" class="level3">
<h3 class="anchored" data-anchor-id="example-2">Example 2</h3>
<p><strong>Prompt from the dataset:</strong></p>
<blockquote class="blockquote">
<p>About the third point, can you give me a sentence to add?</p>
</blockquote>
<p><strong>ChatGPT said:</strong></p>
<blockquote class="blockquote">
<p>Sure — here’s a sentence you could add to support the third point about South Korea:</p>
<p><em>For example, in South Korea, the income gap between the richest and poorest citizens has continued to widen, with the top 20 percent of earners making more than five times the income of the bottom 20 percent, highlighting the growing inequality despite the country’s rapid economic development.</em></p>
<p>Would you like me to make it sound a bit simpler to match a school-essay tone?</p>
</blockquote>
<hr>
<p>In these cases, <strong>Study Mode behaved almost identically to ChatGPT-5</strong>, except that it added a short <em>template preface</em> such as <em>“Sure — here’s a clear and well-structured paragraph on economic benefits.”</em></p>
<p>For the <strong>remaining seven responses</strong>, Study Mode did not provide a complete paragraph in the very first turn. Instead, it showed a clear <strong>tendency toward full text generation</strong>: before producing the paragraph, it asked users to clarify details like tone, style, or target audience. Yet, after only <strong>one to three clarification turns</strong>, it still ended up generating a finished essay-style paragraph.</p>
<hr>
</section>
</section>
<section id="my-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="my-interpretation">My Interpretation</h2>
<p>I’m guessing this pattern might have something to do with how ChatGPT is <strong>fundamentally optimized during training</strong>. Even though Study Mode is designed to promote reflection and learning, the underlying model is still trained through <strong>reinforcement learning from human feedback (RLHF)</strong> — a process that heavily rewards the model for being <em>helpful, relevant,</em> and <em>obedient</em> to user instructions.</p>
<p>In other words, the system learns that the “right” thing to do is to <strong>fulfill the user’s request as directly and smoothly as possible</strong>.</p>
<p>So when a student explicitly asks, <em>“Write me a paragraph about…”</em>, the model’s internal reward signals are already biased toward delivering a finished product, not resisting or reframing the task in a more pedagogical way. Study Mode might overlay a layer of <em>instructional politeness</em> — adding phrases like <em>“Let’s clarify your tone first”</em> or <em>“What style would you like?”</em> — but these are more like <strong>cosmetic scaffolds</strong> rather than deep behavioral changes. After a few turns, once the clarifications are “satisfied,” the model reverts to what it’s rewarded for: producing coherent text that looks like a completed answer.</p>
<p>Another possible reason is the <strong>interactional pressure</strong> between students and the model. In classroom data, students rarely want prolonged dialogue; they expect <strong>immediate, concrete help</strong>. ChatGPT likely picks up on this pattern: if the user continues prompting in a task-oriented way (<em>“Can you just write it?”</em>), the model quickly shifts back to a <strong>service role</strong> rather than a <strong>tutoring role</strong>.</p>
<p>In this sense, the model is acting more like a <strong>compliant assistant</strong> than a <strong>resistant teacher</strong> — reflecting a deeper tension in the design of AI learning tools.</p>
<p>So even though Study Mode introduces a <strong>pedagogical mask</strong>, its <strong>core behavioral incentives</strong> still come from the same system that drives ChatGPT-5. That might explain why, after one or two clarification turns, it ends up doing exactly what it was built to do: <strong>generate the text, not guide the learning.</strong></p>
<p>````</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/CharlotteZSY0205\.github\.io\/comm4190_F25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>