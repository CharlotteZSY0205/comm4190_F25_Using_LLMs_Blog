<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shiyang Zhang">
<meta name="dcterms.date" content="2025-09-18">
<meta name="description" content="Fixing bugs, refining the interface, and learning how to “talk to AI” so it gives me the exact code I need.">

<title>Two Days, One Extension: How I Build My First Extension With Cline (Part 2) – Shiyang’s Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1db3f541d99483cdc7a0d9cf38862b2c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Shiyang’s Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Two Days, One Extension: How I Build My First Extension With Cline (Part 2)</h1>
                  <div>
        <div class="description">
          Fixing bugs, refining the interface, and learning how to “talk to AI” so it gives me the exact code I need.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Coding</div>
                <div class="quarto-category">Extension Devlopment</div>
                <div class="quarto-category">Cline</div>
                <div class="quarto-category">Codex</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shiyang Zhang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 18, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="my-debugging-workflow-me-to-describe-chatgpt-to-refine-cline-to-write-code" class="level2">
<h2 class="anchored" data-anchor-id="my-debugging-workflow-me-to-describe-chatgpt-to-refine-cline-to-write-code">My Debugging Workflow: Me to describe → ChatGPT to refine → Cline to write code</h2>
<ol type="1">
<li><p><strong>Self-Testing and Recording</strong> I begin by testing the plugin myself in real scenarios. I record the exact steps where issues occur, note the expected vs.&nbsp;actual behavior, and keep screenshots or short recordings when necessary. I also make a quick verbal note of the effect I want, including non-functional aspects such as consistency, accessibility, and performance.</p></li>
<li><p><strong>Turning Verbal Notes into Structured Specifications</strong> I then describe the issue informally to ChatGPT. Its role is to reorganize my raw, messy descriptions into a clear, logically structured specification: defining the problem, reproducing steps, acceptance criteria, edge cases, and the intended fix. The idea is to turn “natural language frustration” into “an actionable task.”</p></li>
<li><p><strong>Passing Structured Specs to the Client/Agent</strong> Once ChatGPT produces a polished specification, I copy this into the client side for actual modification. When UI or interaction is involved, I emphasize that the flow and design guidelines must be aligned before touching the code.</p></li>
<li><p><strong>Re-Testing and Regression</strong> After the client makes changes, I test again using the acceptance criteria. I check both normal and edge cases (empty inputs, switching modes, collapse/expand, keyboard focus). If regressions appear, I loop back: describe verbally, get ChatGPT to rewrite as a precise patch spec, and resubmit.</p></li>
</ol>
<p>This workflow can be told in a three-part rhythm in the blog: ****. I raise the issue, ChatGPT turns it into a professional spec, and the code gets updated. Each cycle can be illustrated with a screenshot or before/after comparison.</p>
<blockquote class="blockquote">
<p>Since I didn’t take a screenshot every time I discovered and resolved a bug, I’ll instead include a selection of screenshots showing different stages of the extension’s development, where you can see both some of the bugs and their resolved versions</p>
</blockquote>
</section>
<section id="bug-narratives-and-interaction-with-chatgpt" class="level2">
<h2 class="anchored" data-anchor-id="bug-narratives-and-interaction-with-chatgpt">Bug Narratives and Interaction with ChatGPT</h2>
<section id="bug-a-comparison-panel-not-fully-collapsing-triangle-indicator-misaligned" class="level3">
<h3 class="anchored" data-anchor-id="bug-a-comparison-panel-not-fully-collapsing-triangle-indicator-misaligned">Bug A: Comparison Panel Not Fully Collapsing, Triangle Indicator Misaligned</h3>
<p><strong>Where I Noticed It</strong> When I collapsed the comparison panel, the “UseOriginal” and “UseBoosted” buttons were still visible. Above the small triangle, there was also a stray line. The triangle itself was misaligned and undersized.</p>
<p><strong>My Verbal Request</strong> I wanted the panel to collapse completely, leaving only a small triangle as a handle to expand again. The stray line should disappear. The triangle needed to be positioned slightly higher, made larger, rounded at the corners, colored consistently with the “UseBoosted” button, and given a subtle shadow.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ul>
<li><p>Problem: Collapsed state not hiding content, stray visual elements, misaligned and inconsistent triangle.</p></li>
<li><p>Goal: Collapsed view shows only a clickable triangle handle, everything else hidden. Expanding restores previous state and scroll position.</p></li>
<li><p>Acceptance Criteria:</p>
<ol type="1">
<li>Only the triangle is visible when collapsed; other elements are fully hidden and inaccessible.</li>
<li>Triangle has rounded corners, sits slightly above the input box, and is proportionally larger.</li>
<li>Its color matches the “UseBoosted” button and it has a subtle shadow.</li>
<li>Expanding restores content unchanged.</li>
</ol></li>
</ul>
<p><strong>Outcome and Reflection</strong> This change improved both accessibility and user experience. The panel is now truly collapsible, while state persistence ensures the comparison process is not disrupted.</p>
<div style="display: flex; justify-content: center; gap: 20px; align-items: center; margin-bottom:24px; margin-top:24px;">
<p><img src="v1 .png" width="30%"> <img src="v2.png" width="20%"> <img src="v3.png" width="30%"></p>
</div>
</section>
<section id="bug-b-button-inconsistencies-clear-edit-delete" class="level3">
<h3 class="anchored" data-anchor-id="bug-b-button-inconsistencies-clear-edit-delete">Bug B: Button Inconsistencies (Clear, Edit, Delete)</h3>
<p><strong>Where I Noticed It</strong> The “Clear” button looked different from other buttons. In the Settings page, buttons for editing, deleting, and adding prompts had visible borders that clashed with the rest of the design.</p>
<p><strong>My Verbal Request</strong> I wanted the “Clear” button to look consistent with other buttons, and for all Settings page action buttons to have no border lines.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ul>
<li>Problem: Inconsistent button design language.</li>
<li>Goal: Unify button system (size, corner radius, font, spacing). Action buttons should use a borderless style.</li>
<li>Guidelines: Border: Same color/transparent as the background, visually appearing borderless (border: 1px solid transparent) to avoid a darker outline. Idle State:</li>
<li>Background: Neutral color (e.g., #F5F5F7 or system light gray), transparent border.</li>
<li>Font: Medium contrast.</li>
<li>Hover: Subtle shadow or light elevation, no border color change. Active State:</li>
<li>Background: Light fill of brand color (e.g., –brand-50), border remains transparent.</li>
<li>Font/Icon: Darker tone of the brand color (e.g., –brand-700).</li>
<li>Optional: Inner glow or subtle highlight instead of a visible border. Disabled State:</li>
<li>Faded background, reduced text opacity.</li>
<li>Used only in rare cases such as “in processing” or “switching not allowed.”</li>
</ul>
<p><strong>Outcome and Reflection</strong> A consistent button system reduced visual noise and made interactions easier to understand at a glance.</p>
</section>
<section id="bug-c-my-prompts-text-and-add-button-layout" class="level3">
<h3 class="anchored" data-anchor-id="bug-c-my-prompts-text-and-add-button-layout">Bug C: My Prompts Text and Add Button Layout</h3>
<p><strong>Where I Noticed It</strong> The My Prompts section displayed too many explanatory lines, and the “Add” button’s position conflicted with the title.</p>
<p><strong>My Verbal Request</strong> I wanted to keep only the line: <em>“Drag to reorder. Top 3 appear as buttons above the input.”</em> The other sentences should be removed. The “Add” button should move to the top-right corner of the prompt items container, slightly above the list, and not aligned with the section title. Its style should match the “Save Connection” button, and it should have a background color even when idle.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ul>
<li><p>Goal: Simplify helper text and reposition “Add” for clarity.</p></li>
<li><p>Acceptance Criteria:</p>
<ol type="1">
<li>Only the concise helper text remains.</li>
<li>“Add” button is visually aligned with the prompt list container, not the header.</li>
<li>“Add” button design matches “Save Connection” and has a default background color.</li>
</ol></li>
</ul>
<p><strong>Outcome and Reflection</strong> The section is cleaner and the Add button’s placement now clearly signals its scope of action.</p>
<div style="display: flex; justify-content: center; gap: 20px; align-items: center; margin-bottom:24px; margin-top:24px;">
<p><img src="b1.png" width="35%"> <img src="b2.png" width="35%"> <img src="b3.png" width="35%"></p>
</div>
</section>
<section id="bug-d-remove-default-optimization-style-from-settings-persist-active-mode-via-header-buttons" class="level3">
<h3 class="anchored" data-anchor-id="bug-d-remove-default-optimization-style-from-settings-persist-active-mode-via-header-buttons">Bug D: Remove “Default Optimization Style” from Settings &amp; Persist Active Mode via Header Buttons</h3>
<p><strong>Where I Noticed It</strong> The Settings page still has a “default optimization style” option, which causes confusion because the active mode should really be set from the header buttons in the chat interface.</p>
<p><strong>My Verbal Request</strong> I want to remove the “default optimization style” from Settings completely, and instead let users select and persist their active mode by clicking the header buttons.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ol start="2" type="1">
<li>Remove “default optimization style” from Settings; persist active mode via header buttons</li>
</ol>
<p><strong>Problem</strong> Currently there is a “default optimization style” in Settings. You want to remove that, and instead let the user set their “default” (active) mode by clicking one of the three header buttons above the input box. Once selected, that mode stays active and applies to subsequent messages until the user switches to another mode (or clears it).</p>
<p><strong>Requirements</strong></p>
<p><em>No default in Settings</em></p>
<ul>
<li>Remove the “default optimization style” field/option from Settings entirely.</li>
<li>Settings only manages items (Replace/Append), their content, and their order. The active mode is not chosen in Settings.</li>
</ul>
<p><em>Active mode is chosen in the chat header (three buttons)</em></p>
<ul>
<li><p>Clicking any header button sets that item as the active mode.</p></li>
<li><p>The active mode remains in effect across attempts (i.e., across consecutive sends) until:</p>
<ul>
<li>The user clicks a different header button (which switches the active mode), or</li>
<li>The user clicks a Clear control (see below), or</li>
<li>The active item is deleted/disabled in Settings (auto-clears).</li>
</ul></li>
</ul>
<p><strong>Outcome and Reflection</strong> This change simplifies Settings, removes redundancy, and makes the active mode behavior clearer and more consistent for users.</p>
</section>
<section id="bug-e-enter-key-behavior-interaction-logic" class="level3">
<h3 class="anchored" data-anchor-id="bug-e-enter-key-behavior-interaction-logic">Bug E: Enter Key Behavior &amp; Interaction Logic</h3>
<p><strong>Where I Noticed It</strong> The current system doesn’t fully respect the active mode when pressing Enter, and the role of the mode buttons is slightly unclear.</p>
<p><strong>My Verbal Request</strong> I want pressing Enter to automatically respect whichever mode is active, and the header buttons to be able to toggle off. The three mode buttons should only act as selectors, never sending anything themselves.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ol start="3" type="1">
<li>Enter key respects active mode; header button toggles to clear Requirement</li>
</ol>
<ul>
<li>When any of the three header modes is selected (active), pressing Enter in the chat input must send the boosted prompt (Append = append then send; Replace = replace then send).</li>
<li>Pressing the selected header button again toggles it off (clears active mode). When no mode is active, pressing Enter sends the original prompt (unaltered).</li>
</ul>
<ol type="1">
<li>Interaction Logic (updated) Button Role The three mode buttons (e.g., A / B / C) only select/deselect a mode; they never send. Whatever user type in the input box, if one mode is selected, the input will be modified according to the mode.</li>
</ol>
<p>Workflow</p>
<ol type="1">
<li>The user selects a mode (or clicks the same button again to cancel → returns to “unselected”).</li>
<li>The user finishes typing the prompt.</li>
<li>The user clicks Boost Prompt.</li>
<li>The system rewrites the prompt based on the selected mode → inserts the rewrite into the input field or replaces the existing content (per your replace/append setting), without auto-sending.</li>
<li>The user reviews and sends manually.</li>
</ol>
<p>Selection Rules (single-select, cancelable)</p>
<ul>
<li>Click an unselected button → it becomes selected; others are deselected.</li>
<li>Click the selected button again → deselect and enter “no mode.”</li>
</ul>
<p>Additional Rules</p>
<ul>
<li>Append mode: never auto-sends.</li>
<li>Boosted Prompt mode: never auto-sends and must preserve the comparison panel (before vs.&nbsp;after) previously designed. Do not remove that panel.</li>
</ul>
<p><strong>Outcome and Reflection</strong> This ensures consistency: pressing Enter follows the currently active mode, but users can clear modes by toggling buttons. It also clarifies that mode buttons are selectors only, preserving manual control over sending.</p>
<div style="display: flex; justify-content: center; gap: 20px; align-items: center; margin-bottom:24px; margin-top:24px;">
<p><img src="c1.png" width="35%"> <img src="c2.png" width="35%"> <img src="c3.png" width="35%"></p>
</div>
</section>
<section id="bug-f-prompt-item-borders-and-font-weight" class="level3">
<h3 class="anchored" data-anchor-id="bug-f-prompt-item-borders-and-font-weight">Bug F: Prompt Item Borders and Font Weight</h3>
<p><strong>Where I Noticed It</strong> Each prompt item (like Emoji, Creative, Translation) had light borders, which made the layout look cluttered. The Edit and Delete labels were also slightly oversized.</p>
<p><strong>My Verbal Request</strong> I wanted to remove the borders, reduce the font size of Edit and Delete slightly, and keep the Add button with a background even in its idle state.</p>
<p><strong>ChatGPT’s Reorganized Specification</strong></p>
<ul>
<li><p>Goal: Remove unnecessary card borders, rely on spacing to separate items, and adjust typography for action labels.</p></li>
<li><p>Acceptance Criteria:</p>
<ol type="1">
<li>No visible borders around prompt items; spacing and padding define structure.</li>
<li>Edit/Delete labels use a slightly smaller font size.</li>
<li>Add button retains a default background.</li>
</ol></li>
</ul>
<p><strong>Outcome and Reflection</strong> The result is a cleaner, more modern look. The list feels lighter and more professional, while action labels no longer dominate visually.</p>
</section>
</section>
<section id="takeaways" class="level2">
<h2 class="anchored" data-anchor-id="takeaways">Takeaways</h2>
<p>First, collaborating with AI to develop an extension or software is ideal for multitasking. Since AI needs time to process requirements, analyze the code, and propose the best strategy, I can use that waiting period to focus on other tasks. For example, while developing this extension, I also worked on writing a blog about the process. This not only saved time but also helped me keep a fresh memory of the entire workflow.</p>
<p>Second, it’s important to remember to push the code once it reaches a satisfactory state. If you move on to the next iteration and AI introduces major changes that worsen the outcome, you’ll want to revert to the earlier version — which is only possible if you’ve pushed it beforehand. As a bonus tip, if you’re unhappy with the current version, you can use git stash to temporarily save it in a separate place. That way, you can easily return to the most recent pushed version whenever needed.</p>
<p>Third, even though AI is capable of debugging, we still need to remain flexible and adapt to the current status of the code. Sometimes, when AI fails to achieve a goal after several attempts, it becomes necessary to explore alternative solutions. For instance, I found it useful to ask AI to generate logs and then feed those logs back into the system. This gave AI a clearer understanding of what had been accomplished and what went wrong. In other words, we cannot simply expect AI to finish the task on its own — we have to think critically and provide multiple options or strategies to guide it.</p>
<p>Finally, although describing bugs and formulating a well-structured request for ChatGPT can make inputs more organized, I noticed that sometimes a plain and simple description written directly by me led to more effective debugging. I suspect this is because ChatGPT’s reorganized versions can be overly long or mundane, adding unnecessary noise for both the model and the client to process. In these cases, relying on my own straightforward explanation worked better than depending on ChatGPT’s reformulations.</p>
<p>Throughout the creation, I found that whether it was drafting the design document or writing the code, I found that the AI considered all the essential aspects of building an extension. It even anticipated how users would navigate the extension and added many features and options beyond my original requirements, which I found quite amazing. For example, I never gave any instructions on the visual design, but GPT-5 automatically chose a sleek purple theme with gradient effects and designed the button styles and the settings page layout. I hardly made any changes to this style because it was already more than satisfactory. Later, when I asked GPT-5 to refine the design by removing the button border, it provided a detailed color specification covering three states: unselected, hover, and selected. This level of comprehensiveness went far beyond my expectations, since I wouldn’t have thought to account for all those conditions. In terms of functionality, the AI also created features I hadn’t considered, such as an API input bar and an option allowing users to preview the modified prompt before sending it. What impressed me most was that I didn’t need to specify every detail — with only simple descriptions from me, the AI was able to design thoughtful features and interfaces on its own.</p>
<p>````</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/CharlotteZSY0205\.github\.io\/comm4190_F25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>